<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Analytics Dashboard - HOTO Process</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        :root {
            --cbre-blue: #1F3765;
            --cbre-light-blue: #3E7CA6;
            --cbre-celadon: #80BBAD;
            --cbre-green: #17E88F;
            --cbre-orange: #D2785A;
            --cbre-purple: #885073;
        }
        
        .chart-container {
            position: relative;
            height: 300px;
            margin-bottom: 30px;
        }
        
        .stat-tile {
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            color: white;
            text-align: center;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            transition: transform 0.3s;
        }
        
        .stat-tile:hover {
            transform: translateY(-5px);
        }
        
        .stat-tile h3 {
            font-size: 2.5rem;
            margin: 10px 0;
            font-weight: 700;
        }
        
        .date-filter {
            background: white;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
            margin-bottom: 20px;
        }
        
        .data-table {
            font-size: 0.9rem;
        }
        
        .trend-up {
            color: #198754;
        }
        
        .trend-down {
            color: #dc3545;
        }
        
        .trend-neutral {
            color: #6c757d;
        }
        
        .report-card {
            border: none;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
            transition: transform 0.3s;
            height: 100%;
        }
        
        .report-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 20px rgba(0,0,0,0.1);
        }
        
        .no-data-placeholder {
            text-align: center;
            padding: 40px;
            color: #6c757d;
        }
        
        .no-data-placeholder i {
            font-size: 3rem;
            margin-bottom: 15px;
            opacity: 0.5;
        }
        
        .data-warning-banner {
            background: linear-gradient(135deg, #fff3cd 0%, #ffeaa7 100%);
            border-left: 5px solid #ffc107;
            padding: 15px;
            margin-bottom: 20px;
            border-radius: 5px;
        }
        
        .efficiency-badge {
            font-size: 0.8rem;
            padding: 4px 8px;
            border-radius: 20px;
        }
        
        .export-buttons {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            margin-bottom: 15px;
        }
        
        .export-btn {
            padding: 8px 15px;
            border-radius: 5px;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .chart-placeholder {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: #6c757d;
            font-size: 1.1rem;
        }
        
        .chart-placeholder i {
            font-size: 3rem;
            margin-bottom: 15px;
            opacity: 0.3;
        }
        
        @media print {
            .no-print {
                display: none !important;
            }
            
            .report-card {
                box-shadow: none !important;
                border: 1px solid #dee2e6 !important;
            }
        }
    </style>
</head>
<body>
    <!-- Data Warning Alert -->
    <div id="dataWarning" class="data-warning-banner m-3 no-print">
        <div class="d-flex justify-content-between align-items-center">
            <div>
                <i class="fas fa-exclamation-triangle text-warning me-2"></i>
                <strong>No Data Found!</strong> Dashboard is showing placeholder values. 
                Please add data first to see real analytics.
            </div>
            <div>
                <a href="data-entry.html" class="btn btn-sm btn-warning me-2">
                    <i class="fas fa-key"></i> Add Data Entry
                </a>
                <a href="excel-processor.html" class="btn btn-sm btn-outline-warning">
                    <i class="fas fa-file-excel"></i> Import Excel
                </a>
            </div>
        </div>
    </div>
    
    <div class="container-fluid py-4">
        <!-- Header -->
        <div class="row mb-4">
            <div class="col-md-6">
                <h2><i class="fas fa-chart-bar"></i> Analytics Dashboard</h2>
                <p class="text-muted">Performance metrics and trend analysis for HOT Process</p>
            </div>
            <div class="col-md-6">
                <div class="export-buttons no-print">
                    <button class="btn btn-outline-primary export-btn" onclick="exportAsPDF()">
                        <i class="fas fa-file-pdf"></i> PDF
                    </button>
                    <button class="btn btn-outline-success export-btn" onclick="exportAsExcel()">
                        <i class="fas fa-file-excel"></i> Excel
                    </button>
                    <button class="btn btn-outline-dark export-btn" onclick="exportAsCSV()">
                        <i class="fas fa-file-csv"></i> CSV
                    </button>
                    <button class="btn btn-primary ms-2" onclick="printDashboard()">
                        <i class="fas fa-print"></i> Print
                    </button>
                    <a href="index.html" class="btn btn-outline-secondary">
                        <i class="fas fa-arrow-left"></i> Back
                    </a>
                </div>
            </div>
        </div>
        
        <!-- Date Filter -->
        <div class="date-filter no-print">
            <div class="row align-items-center">
                <div class="col-md-3">
                    <h6 class="mb-0"><i class="fas fa-calendar-alt me-2"></i>Date Range</h6>
                </div>
                <div class="col-md-6">
                    <div class="row">
                        <div class="col">
                            <label class="form-label small">From</label>
                            <input type="date" class="form-control" id="startDate" value="">
                        </div>
                        <div class="col-auto d-flex align-items-end">
                            <span class="align-bottom">to</span>
                        </div>
                        <div class="col">
                            <label class="form-label small">To</label>
                            <input type="date" class="form-control" id="endDate" value="">
                        </div>
                    </div>
                </div>
                <div class="col-md-3">
                    <button class="btn btn-primary w-100 mt-3" onclick="loadAnalytics()">
                        <i class="fas fa-filter"></i> Apply Filter
                    </button>
                </div>
            </div>
            <div class="row mt-3">
                <div class="col-md-12">
                    <div class="btn-group w-100" role="group">
                        <button type="button" class="btn btn-outline-secondary btn-sm" onclick="setDateRange('week')">
                            <i class="fas fa-calendar-week"></i> Last 7 Days
                        </button>
                        <button type="button" class="btn btn-outline-secondary btn-sm" onclick="setDateRange('month')">
                            <i class="fas fa-calendar"></i> Last 30 Days
                        </button>
                        <button type="button" class="btn btn-outline-secondary btn-sm" onclick="setDateRange('quarter')">
                            <i class="fas fa-calendar-alt"></i> Last 90 Days
                        </button>
                        <button type="button" class="btn btn-outline-secondary btn-sm" onclick="setDateRange('year')">
                            <i class="fas fa-calendar-year"></i> Last 365 Days
                        </button>
                        <button type="button" class="btn btn-outline-secondary btn-sm" onclick="setDateRange('all')">
                            <i class="fas fa-infinity"></i> All Time
                        </button>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Stats Tiles -->
        <div class="row mb-4">
            <div class="col-md-2">
                <div class="stat-tile" style="background: linear-gradient(135deg, var(--cbre-blue) 0%, #2a4a8a 100%);">
                    <i class="fas fa-key fa-2x mb-2"></i>
                    <h3 id="statKeys">0</h3>
                    <p class="mb-1">Key Handovers</p>
                    <small id="keyTrend" class="trend-neutral">No data</small>
                </div>
            </div>
            <div class="col-md-2">
                <div class="stat-tile" style="background: linear-gradient(135deg, var(--cbre-green) 0%, #1dc47e 100%);">
                    <i class="fas fa-search fa-2x mb-2"></i>
                    <h3 id="statSnags">0</h3>
                    <p class="mb-1">Snagging Completed</p>
                    <small id="snagTrend" class="trend-neutral">No data</small>
                </div>
            </div>
            <div class="col-md-2">
                <div class="stat-tile" style="background: linear-gradient(135deg, var(--cbre-orange) 0%, #e08a6b 100%);">
                    <i class="fas fa-calendar-check fa-2x mb-2"></i>
                    <h3 id="statVisits">0</h3>
                    <p class="mb-1">First Visits</p>
                    <small id="visitTrend" class="trend-neutral">No data</small>
                </div>
            </div>
            <div class="col-md-2">
                <div class="stat-tile" style="background: linear-gradient(135deg, var(--cbre-light-blue) 0%, #5b96c4 100%);">
                    <i class="fas fa-handshake fa-2x mb-2"></i>
                    <h3 id="statHandovers">0</h3>
                    <p class="mb-1">Handovers</p>
                    <small id="handoverTrend" class="trend-neutral">No data</small>
                </div>
            </div>
            <div class="col-md-2">
                <div class="stat-tile" style="background: linear-gradient(135deg, var(--cbre-purple) 0%, #a5668e 100%);">
                    <i class="fas fa-home fa-2x mb-2"></i>
                    <h3 id="statMoveins">0</h3>
                    <p class="mb-1">Move-ins</p>
                    <small id="moveinTrend" class="trend-neutral">No data</small>
                </div>
            </div>
            <div class="col-md-2">
                <div class="stat-tile" style="background: linear-gradient(135deg, var(--cbre-celadon) 0%, #9ad4c4 100%);">
                    <i class="fas fa-clock fa-2x mb-2"></i>
                    <h3 id="statAvgTime">0</h3>
                    <p class="mb-1">Avg Time (Days)</p>
                    <small>Snagâ†’Handover</small>
                </div>
            </div>
        </div>
        
        <!-- Charts Row 1 -->
        <div class="row mb-4">
            <div class="col-md-6">
                <div class="card report-card">
                    <div class="card-header d-flex justify-content-between align-items-center">
                        <h5 class="mb-0"><i class="fas fa-chart-line me-2"></i>Monthly Progress Trend</h5>
                        <button class="btn btn-sm btn-outline-primary no-print" onclick="toggleChartData('monthly')">
                            <i class="fas fa-sync"></i> Refresh
                        </button>
                    </div>
                    <div class="card-body">
                        <div class="chart-container">
                            <canvas id="monthlyChart"></canvas>
                            <div id="monthlyNoData" class="chart-placeholder" style="display: none;">
                                <i class="fas fa-chart-line"></i>
                                <p>No monthly data available</p>
                                <small class="text-muted">Add data to see trends</small>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="col-md-6">
                <div class="card report-card">
                    <div class="card-header d-flex justify-content-between align-items-center">
                        <h5 class="mb-0"><i class="fas fa-building me-2"></i>Tower-wise Performance</h5>
                        <button class="btn btn-sm btn-outline-primary no-print" onclick="toggleChartData('tower')">
                            <i class="fas fa-sync"></i> Refresh
                        </button>
                    </div>
                    <div class="card-body">
                        <div class="chart-container">
                            <canvas id="towerChart"></canvas>
                            <div id="towerNoData" class="chart-placeholder" style="display: none;">
                                <i class="fas fa-building"></i>
                                <p>No tower data available</p>
                                <small class="text-muted">Add data to compare towers</small>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Charts Row 2 -->
        <div class="row mb-4">
            <div class="col-md-4">
                <div class="card report-card">
                    <div class="card-header d-flex justify-content-between align-items-center">
                        <h5 class="mb-0"><i class="fas fa-chart-pie me-2"></i>Snagging Status Distribution</h5>
                        <button class="btn btn-sm btn-outline-primary no-print" onclick="toggleChartData('snag')">
                            <i class="fas fa-sync"></i> Refresh
                        </button>
                    </div>
                    <div class="card-body">
                        <div class="chart-container">
                            <canvas id="snagPieChart"></canvas>
                            <div id="snagNoData" class="chart-placeholder" style="display: none;">
                                <i class="fas fa-chart-pie"></i>
                                <p>No snagging data available</p>
                                <small class="text-muted">Complete snagging to see distribution</small>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="col-md-8">
                <div class="card report-card">
                    <div class="card-header d-flex justify-content-between align-items-center">
                        <h5 class="mb-0"><i class="fas fa-calendar-week me-2"></i>Weekly Performance Metrics</h5>
                        <button class="btn btn-sm btn-outline-primary no-print" onclick="refreshWeeklyTable()">
                            <i class="fas fa-redo"></i> Refresh
                        </button>
                    </div>
                    <div class="card-body">
                        <div class="table-responsive">
                            <table class="table data-table table-hover">
                                <thead class="table-light">
                                    <tr>
                                        <th>Week</th>
                                        <th>Keys</th>
                                        <th>Snagging</th>
                                        <th>Visits</th>
                                        <th>Handovers</th>
                                        <th>Move-ins</th>
                                        <th>Avg Time (Days)</th>
                                        <th>Efficiency</th>
                                    </tr>
                                </thead>
                                <tbody id="weeklyTable">
                                    <tr id="weeklyNoData">
                                        <td colspan="8" class="text-center text-muted py-4">
                                            <i class="fas fa-calendar-week me-2"></i>
                                            No weekly data available. Select a date range to see metrics.
                                        </td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Additional Charts Row -->
        <div class="row mb-4">
            <div class="col-md-12">
                <div class="card report-card">
                    <div class="card-header d-flex justify-content-between align-items-center">
                        <h5 class="mb-0"><i class="fas fa-chart-area me-2"></i>Process Flow Timeline</h5>
                        <button class="btn btn-sm btn-outline-primary no-print" onclick="toggleChartData('timeline')">
                            <i class="fas fa-sync"></i> Refresh
                        </button>
                    </div>
                    <div class="card-body">
                        <div class="chart-container">
                            <canvas id="timelineChart"></canvas>
                            <div id="timelineNoData" class="chart-placeholder" style="display: none;">
                                <i class="fas fa-chart-area"></i>
                                <p>No timeline data available</p>
                                <small class="text-muted">Complete multiple process steps to see timeline</small>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Reports Section -->
        <div class="row no-print">
            <div class="col-md-12">
                <div class="card">
                    <div class="card-header">
                        <h5 class="mb-0"><i class="fas fa-file-alt me-2"></i>Quick Reports</h5>
                    </div>
                    <div class="card-body">
                        <div class="row">
                            <div class="col-md-3 mb-3">
                                <div class="card border-warning h-100">
                                    <div class="card-body text-center">
                                        <i class="fas fa-clock fa-2x text-warning mb-3"></i>
                                        <h6>Pending Snagging</h6>
                                        <p class="text-muted small">Flats pending snag resolution</p>
                                        <button class="btn btn-sm btn-outline-warning" onclick="generateReport('pending_snags')">
                                            <i class="fas fa-file-alt"></i> Generate Report
                                        </button>
                                    </div>
                                </div>
                            </div>
                            <div class="col-md-3 mb-3">
                                <div class="card border-success h-100">
                                    <div class="card-body text-center">
                                        <i class="fas fa-tachometer-alt fa-2x text-success mb-3"></i>
                                        <h6>Productivity Report</h6>
                                        <p class="text-muted small">Team performance metrics</p>
                                        <button class="btn btn-sm btn-outline-success" onclick="generateReport('productivity')">
                                            <i class="fas fa-file-alt"></i> Generate Report
                                        </button>
                                    </div>
                                </div>
                            </div>
                            <div class="col-md-3 mb-3">
                                <div class="card border-info h-100">
                                    <div class="card-body text-center">
                                        <i class="fas fa-chart-line fa-2x text-info mb-3"></i>
                                        <h6>Trend Analysis</h6>
                                        <p class="text-muted small">Performance trends over time</p>
                                        <button class="btn btn-sm btn-outline-info" onclick="generateReport('trends')">
                                            <i class="fas fa-file-alt"></i> Generate Report
                                        </button>
                                    </div>
                                </div>
                            </div>
                            <div class="col-md-3 mb-3">
                                <div class="card border-danger h-100">
                                    <div class="card-body text-center">
                                        <i class="fas fa-exclamation-triangle fa-2x text-danger mb-3"></i>
                                        <h6>Alerts Summary</h6>
                                        <p class="text-muted small">Critical issues and delays</p>
                                        <button class="btn btn-sm btn-outline-danger" onclick="generateReport('alerts')">
                                            <i class="fas fa-file-alt"></i> Generate Report
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Scripts -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        // Analytics Dashboard JavaScript
        let charts = {
            monthly: null,
            tower: null,
            snag: null,
            timeline: null
        };
        
        let hasRealData = false;
        let currentStats = {};
        let previousPeriodStats = {};
        
        document.addEventListener('DOMContentLoaded', function() {
            // Set default date range (last 30 days)
            setDateRange('month');
            
            // Check for data and load analytics
            checkForData();
            loadAnalytics();
            
            // Set up auto-refresh every 5 minutes
            setInterval(checkForDataUpdates, 300000);
        });
        
        // Set date range
        function setDateRange(rangeType) {
            const endDate = new Date();
            const startDate = new Date();
            
            switch(rangeType) {
                case 'week':
                    startDate.setDate(startDate.getDate() - 7);
                    break;
                case 'month':
                    startDate.setDate(startDate.getDate() - 30);
                    break;
                case 'quarter':
                    startDate.setDate(startDate.getDate() - 90);
                    break;
                case 'year':
                    startDate.setDate(startDate.getDate() - 365);
                    break;
                case 'all':
                    // Set to a very old date
                    startDate.setFullYear(2020, 0, 1);
                    break;
            }
            
            document.getElementById('startDate').value = startDate.toISOString().split('T')[0];
            document.getElementById('endDate').value = endDate.toISOString().split('T')[0];
            
            // Load previous period stats for trend comparison
            loadPreviousPeriodStats(startDate, endDate);
            loadAnalytics();
        }
        
        // Load previous period stats for trend comparison
        function loadPreviousPeriodStats(currentStart, currentEnd) {
            const periodDays = Math.floor((currentEnd - currentStart) / (1000 * 60 * 60 * 24));
            const previousStart = new Date(currentStart);
            previousStart.setDate(previousStart.getDate() - periodDays - 1);
            const previousEnd = new Date(currentStart);
            previousEnd.setDate(previousEnd.getDate() - 1);
            
            const hotData = getHOTData();
            previousPeriodStats = calculateStatistics(hotData, previousStart, previousEnd);
        }
        
        // Check if real data exists
        function checkForData() {
            try {
                const hotData = JSON.parse(localStorage.getItem('hot_process_data'));
                const sampleData = localStorage.getItem('sample_data_loaded');
                
                // Check if there's real data (not just sample data)
                hasRealData = false;
                
                if (hotData) {
                    // Check each tower for actual data
                    ['A', 'B', 'C'].forEach(tower => {
                        if (hotData.towers && hotData.towers[tower] && hotData.towers[tower].flats) {
                            const flats = Object.values(hotData.towers[tower].flats);
                            if (flats.length > 0) {
                                // Check if any flat has real data
                                flats.forEach(flat => {
                                    if (flat.keyHandover || flat.snagging || flat.firstVisit || flat.handover) {
                                        hasRealData = true;
                                    }
                                });
                            }
                        }
                    });
                }
                
                // Show/hide data warning
                const warningElement = document.getElementById('dataWarning');
                if (hasRealData) {
                    warningElement.style.display = 'none';
                } else {
                    warningElement.style.display = 'block';
                }
                
                return hasRealData;
                
            } catch (error) {
                console.error('Error checking data:', error);
                hasRealData = false;
                document.getElementById('dataWarning').style.display = 'block';
                return false;
            }
        }
        
        // Check for data updates
        function checkForDataUpdates() {
            const previousDataState = hasRealData;
            const newDataState = checkForData();
            
            if (previousDataState !== newDataState) {
                loadAnalytics();
                showNotification('Data updated', 'info');
            }
        }
        
        // Load analytics data
        function loadAnalytics() {
            // Get date range
            const startDate = document.getElementById('startDate').value;
            const endDate = document.getElementById('endDate').value;
            
            if (!startDate || !endDate) {
                alert('Please select both start and end dates');
                return;
            }
            
            // Load data from localStorage
            const hotData = getHOTData();
            
            // Calculate statistics
            currentStats = calculateStatistics(hotData, startDate, endDate);
            
            // Update UI
            updateStats(currentStats);
            
            // Create or update charts
            createCharts(currentStats);
            
            // Update weekly table
            updateWeeklyTable(currentStats);
            
            // Show notification if no real data
            if (!hasRealData) {
                showChartPlaceholders();
            }
        }
        
        // Get HOT data from localStorage
        function getHOTData() {
            try {
                const storedData = localStorage.getItem('hot_process_data');
                if (!storedData) {
                    return {
                        towers: {
                            A: { flats: {} },
                            B: { flats: {} },
                            C: { flats: {} }
                        }
                    };
                }
                
                return JSON.parse(storedData);
                
            } catch (error) {
                console.error('Error loading data:', error);
                return {
                    towers: {
                        A: { flats: {} },
                        B: { flats: {} },
                        C: { flats: {} }
                    }
                };
            }
        }
        
        // Calculate statistics from data
        function calculateStatistics(data, startDate, endDate) {
            const start = new Date(startDate);
            const end = new Date(endDate);
            end.setHours(23, 59, 59, 999); // Include entire end date
            
            const stats = {
                keys: 0,
                snags: 0,
                visits: 0,
                handovers: 0,
                moveins: 0,
                avgTime: 0,
                byTower: { 
                    A: { keys: 0, snags: 0, visits: 0, handovers: 0, moveins: 0 },
                    B: { keys: 0, snags: 0, visits: 0, handovers: 0, moveins: 0 },
                    C: { keys: 0, snags: 0, visits: 0, handovers: 0, moveins: 0 }
                },
                snagStatus: { completed: 0, pending: 0, delayed: 0, not_started: 0 },
                monthlyData: [],
                weeklyData: [],
                timelineData: []
            };
            
            let totalSnagToHandoverDays = 0;
            let countSnagToHandover = 0;
            
            // Process data
            ['A', 'B', 'C'].forEach(tower => {
                const towerData = data.towers[tower];
                if (towerData && towerData.flats) {
                    const flats = towerData.flats;
                    
                    Object.entries(flats).forEach(([flatId, flatData]) => {
                        // Key handovers
                        if (flatData.keyHandover && flatData.keyHandover.date) {
                            const keyDate = new Date(flatData.keyHandover.date);
                            if (keyDate >= start && keyDate <= end) {
                                stats.keys++;
                                stats.byTower[tower].keys++;
                            }
                        }
                        
                        // Snagging
                        if (flatData.snagging) {
                            const snagDate = flatData.snagging.startDate ? 
                                new Date(flatData.snagging.startDate) : null;
                            
                            if (snagDate && snagDate >= start && snagDate <= end) {
                                stats.snags++;
                                stats.byTower[tower].snags++;
                                
                                // Snag status
                                if (flatData.snagging.completed === true) {
                                    stats.snagStatus.completed++;
                                } else if (flatData.snagging.status === 'pending') {
                                    stats.snagStatus.pending++;
                                } else if (flatData.snagging.status === 'delayed') {
                                    stats.snagStatus.delayed++;
                                } else {
                                    stats.snagStatus.not_started++;
                                }
                                
                                // Calculate snag to handover time
                                if (flatData.handover && flatData.handover.date) {
                                    const handoverDate = new Date(flatData.handover.date);
                                    const daysDiff = Math.floor((handoverDate - snagDate) / (1000 * 60 * 60 * 24));
                                    if (daysDiff > 0) {
                                        totalSnagToHandoverDays += daysDiff;
                                        countSnagToHandover++;
                                    }
                                }
                            }
                        }
                        
                        // First visits
                        if (flatData.firstVisit && flatData.firstVisit.visitDate) {
                            const visitDate = new Date(flatData.firstVisit.visitDate);
                            if (visitDate >= start && visitDate <= end) {
                                stats.visits++;
                                stats.byTower[tower].visits++;
                            }
                        }
                        
                        // Handovers
                        if (flatData.handover && flatData.handover.date) {
                            const handoverDate = new Date(flatData.handover.date);
                            if (handoverDate >= start && handoverDate <= end) {
                                stats.handovers++;
                                stats.byTower[tower].handovers++;
                            }
                        }
                        
                        // Move-ins
                        if (flatData.interiors && flatData.interiors.moveInDate) {
                            const moveInDate = new Date(flatData.interiors.moveInDate);
                            if (moveInDate >= start && moveInDate <= end) {
                                stats.moveins++;
                                stats.byTower[tower].moveins++;
                            }
                        }
                    });
                }
            });
            
            // Calculate average time
            stats.avgTime = countSnagToHandover > 0 ? 
                Math.round(totalSnagToHandoverDays / countSnagToHandover) : 0;
            
            // Generate monthly data for charts
            stats.monthlyData = generateMonthlyData(data, start, end);
            stats.weeklyData = generateWeeklyData(data, start, end);
            stats.timelineData = generateTimelineData(data, start, end);
            
            return stats;
        }
        
        // Generate monthly data for charts
        function generateMonthlyData(data, startDate, endDate) {
            const monthlyMap = {};
            const start = new Date(startDate);
            const end = new Date(endDate);
            
            // Initialize all months in range
            const current = new Date(start);
            while (current <= end) {
                const monthYear = current.toLocaleDateString('en-US', { month: 'short', year: '2-digit' });
                monthlyMap[monthYear] = { keys: 0, handovers: 0 };
                current.setMonth(current.getMonth() + 1);
            }
            
            // Count actual data
            ['A', 'B', 'C'].forEach(tower => {
                const towerData = data.towers[tower];
                if (towerData && towerData.flats) {
                    Object.values(towerData.flats).forEach(flatData => {
                        // Key handovers
                        if (flatData.keyHandover && flatData.keyHandover.date) {
                            const date = new Date(flatData.keyHandover.date);
                            if (date >= start && date <= end) {
                                const monthKey = date.toLocaleDateString('en-US', { month: 'short', year: '2-digit' });
                                if (monthlyMap[monthKey]) {
                                    monthlyMap[monthKey].keys++;
                                }
                            }
                        }
                        
                        // Handovers
                        if (flatData.handover && flatData.handover.date) {
                            const date = new Date(flatData.handover.date);
                            if (date >= start && date <= end) {
                                const monthKey = date.toLocaleDateString('en-US', { month: 'short', year: '2-digit' });
                                if (monthlyMap[monthKey]) {
                                    monthlyMap[monthKey].handovers++;
                                }
                            }
                        }
                    });
                }
            });
            
            // Sort by date
            const sortedMonths = Object.keys(monthlyMap).sort((a, b) => {
                return new Date('01 ' + a) - new Date('01 ' + b);
            });
            
            return {
                labels: sortedMonths,
                keys: sortedMonths.map(m => monthlyMap[m].keys),
                handovers: sortedMonths.map(m => monthlyMap[m].handovers)
            };
        }
        
        // Generate weekly data
        function generateWeeklyData(data, startDate, endDate) {
            const weeklyData = [];
            const start = new Date(startDate);
            const end = new Date(endDate);
            
            // Create weeks
            let currentWeekStart = new Date(start);
            let weekNumber = 1;
            
            while (currentWeekStart <= end) {
                const weekEnd = new Date(currentWeekStart);
                weekEnd.setDate(weekEnd.getDate() + 6);
                if (weekEnd > end) weekEnd = end;
                
                // Count data for this week
                let weekStats = {
                    keys: 0,
                    snags: 0,
                    visits: 0,
                    handovers: 0,
                    moveins: 0,
                    avgTime: 0,
                    efficiency: 0
                };
                
                ['A', 'B', 'C'].forEach(tower => {
                    const towerData = data.towers[tower];
                    if (towerData && towerData.flats) {
                        Object.values(towerData.flats).forEach(flatData => {
                            // Key handovers
                            if (flatData.keyHandover && flatData.keyHandover.date) {
                                const date = new Date(flatData.keyHandover.date);
                                if (date >= currentWeekStart && date <= weekEnd) {
                                    weekStats.keys++;
                                }
                            }
                            
                            // Snagging
                            if (flatData.snagging && flatData.snagging.endDate) {
                                const date = new Date(flatData.snagging.endDate);
                                if (date >= currentWeekStart && date <= weekEnd) {
                                    weekStats.snags++;
                                }
                            }
                            
                            // First visits
                            if (flatData.firstVisit && flatData.firstVisit.visitDate) {
                                const date = new Date(flatData.firstVisit.visitDate);
                                if (date >= currentWeekStart && date <= weekEnd) {
                                    weekStats.visits++;
                                }
                            }
                            
                            // Handovers
                            if (flatData.handover && flatData.handover.date) {
                                const date = new Date(flatData.handover.date);
                                if (date >= currentWeekStart && date <= weekEnd) {
                                    weekStats.handovers++;
                                }
                            }
                            
                            // Move-ins
                            if (flatData.interiors && flatData.interiors.moveInDate) {
                                const date = new Date(flatData.interiors.moveInDate);
                                if (date >= currentWeekStart && date <= weekEnd) {
                                    weekStats.moveins++;
                                }
                            }
                        });
                    }
                });
                
                // Calculate efficiency based on completion rate
                const totalActivities = weekStats.keys + weekStats.snags + weekStats.visits + weekStats.handovers;
                weekStats.efficiency = totalActivities > 0 ? 
                    Math.min(100, Math.round((totalActivities / 50) * 100)) : 0;
                
                weeklyData.push({
                    week: `Week ${weekNumber}`,
                    ...weekStats
                });
                
                currentWeekStart.setDate(currentWeekStart.getDate() + 7);
                weekNumber++;
            }
            
            return weeklyData;
        }
        
        // Generate timeline data
        function generateTimelineData(data, startDate, endDate) {
            const timeline = [];
            const start = new Date(startDate);
            const end = new Date(endDate);
            
            ['A', 'B', 'C'].forEach(tower => {
                const towerData = data.towers[tower];
                if (towerData && towerData.flats) {
                    Object.entries(towerData.flats).forEach(([flatId, flatData]) => {
                        const timelineEntry = {
                            tower: tower,
                            flat: flatId,
                            keyDate: flatData.keyHandover?.date,
                            snagStart: flatData.snagging?.startDate,
                            snagEnd: flatData.snagging?.endDate,
                            visitDate: flatData.firstVisit?.visitDate,
                            handoverDate: flatData.handover?.date,
                            moveInDate: flatData.interiors?.moveInDate
                        };
                        
                        // Check if any date is within range
                        const hasDateInRange = Object.values(timelineEntry).some(val => {
                            if (!val) return false;
                            const date = new Date(val);
                            return date >= start && date <= end;
                        });
                        
                        if (hasDateInRange) {
                            timeline.push(timelineEntry);
                        }
                    });
                }
            });
            
            return timeline.slice(0, 10); // Limit to 10 entries for chart
        }
        
        // Update statistics display
        function updateStats(stats) {
            // Update main stats
            document.getElementById('statKeys').textContent = stats.keys;
            document.getElementById('statSnags').textContent = stats.snags;
            document.getElementById('statVisits').textContent = stats.visits;
            document.getElementById('statHandovers').textContent = stats.handovers;
            document.getElementById('statMoveins').textContent = stats.moveins;
            document.getElementById('statAvgTime').textContent = stats.avgTime || '0';
            
            // Update trend indicators based on actual data comparison
            updateTrendIndicators(stats);
        }
        
        // Update trend indicators
        function updateTrendIndicators(stats) {
            const trends = [
                { id: 'keyTrend', current: stats.keys, previous: previousPeriodStats.keys },
                { id: 'snagTrend', current: stats.snags, previous: previousPeriodStats.snags },
                { id: 'visitTrend', current: stats.visits, previous: previousPeriodStats.visits },
                { id: 'handoverTrend', current: stats.handovers, previous: previousPeriodStats.handovers },
                { id: 'moveinTrend', current: stats.moveins, previous: previousPeriodStats.moveins }
            ];
            
            trends.forEach(trend => {
                const element = document.getElementById(trend.id);
                
                if (hasRealData && trend.previous > 0) {
                    const change = ((trend.current - trend.previous) / trend.previous) * 100;
                    const percent = Math.abs(Math.round(change));
                    const isPositive = change > 0;
                    
                    element.textContent = `${isPositive ? '+' : '-'}${percent}%`;
                    element.className = isPositive ? 'trend-up' : 'trend-down';
                } else if (hasRealData && trend.current > 0) {
                    element.textContent = '+100%';
                    element.className = 'trend-up';
                } else {
                    element.textContent = 'No data';
                    element.className = 'trend-neutral';
                }
            });
        }
        
        // Create or update charts
        function createCharts(stats) {
            // Destroy existing charts
            Object.values(charts).forEach(chart => {
                if (chart) chart.destroy();
            });
            
            // Hide all placeholders initially
            hideChartPlaceholders();
            
            // Only create charts if we have data
            if (!hasRealData || (stats.keys === 0 && stats.snags === 0 && stats.handovers === 0)) {
                showChartPlaceholders();
                return;
            }
            
            // Monthly Chart
            const monthlyCtx = document.getElementById('monthlyChart');
            if (monthlyCtx && stats.monthlyData.labels && stats.monthlyData.labels.length > 0) {
                charts.monthly = new Chart(monthlyCtx, {
                    type: 'line',
                    data: {
                        labels: stats.monthlyData.labels,
                        datasets: [
                            {
                                label: 'Key Handovers',
                                data: stats.monthlyData.keys,
                                borderColor: '#80BBAD',
                                backgroundColor: 'rgba(128, 187, 173, 0.1)',
                                borderWidth: 3,
                                tension: 0.4,
                                fill: true
                            },
                            {
                                label: 'Handovers',
                                data: stats.monthlyData.handovers,
                                borderColor: '#3E7CA6',
                                backgroundColor: 'rgba(62, 124, 166, 0.1)',
                                borderWidth: 3,
                                tension: 0.4,
                                fill: true
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                position: 'top',
                            }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: 'Number of Flats'
                                }
                            }
                        }
                    }
                });
            } else if (monthlyCtx) {
                document.getElementById('monthlyNoData').style.display = 'flex';
            }
            
            // Tower Chart
            const towerCtx = document.getElementById('towerChart');
            if (towerCtx) {
                charts.tower = new Chart(towerCtx, {
                    type: 'bar',
                    data: {
                        labels: ['Tower A', 'Tower B', 'Tower C'],
                        datasets: [
                            {
                                label: 'Key Handovers',
                                data: [
                                    stats.byTower.A.keys || 0,
                                    stats.byTower.B.keys || 0,
                                    stats.byTower.C.keys || 0
                                ],
                                backgroundColor: '#80BBAD'
                            },
                            {
                                label: 'Snagging Completed',
                                data: [
                                    stats.byTower.A.snags || 0,
                                    stats.byTower.B.snags || 0,
                                    stats.byTower.C.snags || 0
                                ],
                                backgroundColor: '#17E88F'
                            },
                            {
                                label: 'Handovers',
                                data: [
                                    stats.byTower.A.handovers || 0,
                                    stats.byTower.B.handovers || 0,
                                    stats.byTower.C.handovers || 0
                                ],
                                backgroundColor: '#3E7CA6'
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                position: 'top',
                            }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: 'Number of Flats'
                                }
                            }
                        }
                    }
                });
            }
            
            // Snag Pie Chart
            const snagCtx = document.getElementById('snagPieChart');
            if (snagCtx && (stats.snagStatus.completed > 0 || stats.snagStatus.pending > 0 || stats.snagStatus.delayed > 0)) {
                charts.snag = new Chart(snagCtx, {
                    type: 'doughnut',
                    data: {
                        labels: ['Completed', 'Pending', 'Delayed', 'Not Started'],
                        datasets: [{
                            data: [
                                stats.snagStatus.completed || 0,
                                stats.snagStatus.pending || 0,
                                stats.snagStatus.delayed || 0,
                                stats.snagStatus.not_started || 0
                            ],
                            backgroundColor: [
                                '#17E88F',
                                '#ffc107',
                                '#dc3545',
                                '#6c757d'
                            ],
                            borderWidth: 2
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                position: 'right',
                            },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        const label = context.label || '';
                                        const value = context.raw || 0;
                                        const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                        const percentage = Math.round((value / total) * 100);
                                        return `${label}: ${value} (${percentage}%)`;
                                    }
                                }
                            }
                        }
                    }
                });
            } else if (snagCtx) {
                document.getElementById('snagNoData').style.display = 'flex';
            }
            
            // Timeline Chart
            const timelineCtx = document.getElementById('timelineChart');
            if (timelineCtx && stats.timelineData.length > 0) {
                // Prepare timeline data
                const timelineLabels = stats.timelineData.map(item => `${item.tower}-${item.flat}`);
                const processStages = [];
                
                stats.timelineData.forEach(item => {
                    let completedStages = 0;
                    let totalStages = 0;
                    
                    if (item.keyDate) completedStages++;
                    if (item.snagEnd) completedStages++;
                    if (item.visitDate) completedStages++;
                    if (item.handoverDate) completedStages++;
                    if (item.moveInDate) completedStages++;
                    
                    totalStages = 5; // Total process stages
                    processStages.push(Math.round((completedStages / totalStages) * 100));
                });
                
                charts.timeline = new Chart(timelineCtx, {
                    type: 'bar',
                    data: {
                        labels: timelineLabels,
                        datasets: [{
                            label: 'Process Completion %',
                            data: processStages,
                            backgroundColor: '#3E7CA6'
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: {
                                beginAtZero: true,
                                max: 100,
                                title: {
                                    display: true,
                                    text: 'Completion %'
                                }
                            }
                        }
                    }
                });
            } else if (timelineCtx) {
                document.getElementById('timelineNoData').style.display = 'flex';
            }
        }
        
        // Show chart placeholders
        function showChartPlaceholders() {
            ['monthly', 'tower', 'snag', 'timeline'].forEach(chart => {
                const placeholder = document.getElementById(`${chart}NoData`);
                if (placeholder) {
                    placeholder.style.display = 'flex';
                }
            });
        }
        
        // Hide chart placeholders
        function hideChartPlaceholders() {
            ['monthly', 'tower', 'snag', 'timeline'].forEach(chart => {
                const placeholder = document.getElementById(`${chart}NoData`);
                if (placeholder) {
                    placeholder.style.display = 'none';
                }
            });
        }
        
        // Update weekly table
        function updateWeeklyTable(stats) {
            const tableBody = document.getElementById('weeklyTable');
            const noDataRow = document.getElementById('weeklyNoData');
            
            // Clear existing rows except the no-data row
            const existingRows = tableBody.querySelectorAll('tr:not(#weeklyNoData)');
            existingRows.forEach(row => row.remove());
            
            // Show no data message if no weekly data
            if (!stats.weeklyData || stats.weeklyData.length === 0) {
                noDataRow.style.display = 'table-row';
                return;
            }
            
            // Hide no data row
            noDataRow.style.display = 'none';
            
            // Add weekly data rows
            stats.weeklyData.forEach(weekData => {
                const row = document.createElement('tr');
                
                // Determine efficiency badge color
                let efficiencyClass = 'bg-secondary';
                if (weekData.efficiency >= 80) efficiencyClass = 'bg-success';
                else if (weekData.efficiency >= 60) efficiencyClass = 'bg-warning';
                else if (weekData.efficiency > 0) efficiencyClass = 'bg-danger';
                
                row.innerHTML = `
                    <td><strong>${weekData.week}</strong></td>
                    <td>${weekData.keys}</td>
                    <td>${weekData.snags}</td>
                    <td>${weekData.visits}</td>
                    <td>${weekData.handovers}</td>
                    <td>${weekData.moveins}</td>
                    <td>${weekData.avgTime || 'N/A'}</td>
                    <td>
                        <span class="badge ${efficiencyClass} efficiency-badge">
                            ${weekData.efficiency}%
                        </span>
                    </td>
                `;
                
                tableBody.appendChild(row);
            });
        }
        
        // Refresh weekly table
        function refreshWeeklyTable() {
            loadAnalytics();
            showNotification('Weekly table refreshed', 'success');
        }
        
        // Toggle chart data
        function toggleChartData(chartType) {
            if (!hasRealData) {
                alert('No real data available. Please add data first.');
                return;
            }
            
            // Recreate the specific chart
            createCharts(currentStats);
            showNotification(`${chartType} chart refreshed`, 'success');
        }
        
        // Generate report
        function generateReport(type) {
            if (!hasRealData) {
                alert('No data available to generate reports. Please add data first.');
                return;
            }
            
            let reportContent = '';
            let filename = '';
            
            switch(type) {
                case 'pending_snags':
                    reportContent = generatePendingSnagsReport();
                    filename = 'Pending_Snags_Report';
                    break;
                case 'productivity':
                    reportContent = generateProductivityReport();
                    filename = 'Productivity_Report';
                    break;
                case 'trends':
                    reportContent = generateTrendsReport();
                    filename = 'Trend_Analysis_Report';
                    break;
                case 'alerts':
                    reportContent = generateAlertsReport();
                    filename = 'Alerts_Summary_Report';
                    break;
            }
            
            // Download report
            downloadReport(reportContent, filename);
        }
        
        // Generate pending snags report
        function generatePendingSnagsReport() {
            const stats = currentStats;
            const dateRange = `${document.getElementById('startDate').value} to ${document.getElementById('endDate').value}`;
            
            return `PENDING SNAGS REPORT
================================================================
Generated: ${new Date().toLocaleString()}
Date Range: ${dateRange}
Report Type: Snagging Status Summary

SUMMARY STATISTICS:
================================================================
Total Snags Identified: ${stats.snags}
- Completed: ${stats.snagStatus.completed} (${stats.snags ? Math.round((stats.snagStatus.completed / stats.snags) * 100) : 0}%)
- Pending: ${stats.snagStatus.pending} (${stats.snags ? Math.round((stats.snagStatus.pending / stats.snags) * 100) : 0}%)
- Delayed: ${stats.snagStatus.delayed} (${stats.snags ? Math.round((stats.snagStatus.delayed / stats.snags) * 100) : 0}%)
- Not Started: ${stats.snagStatus.not_started} (${stats.snags ? Math.round((stats.snagStatus.not_started / stats.snags) * 100) : 0}%)

TOWER-WISE ANALYSIS:
================================================================
Tower A: ${stats.byTower.A.snags} total snags
Tower B: ${stats.byTower.B.snags} total snags
Tower C: ${stats.byTower.C.snags} total snags

PERFORMANCE METRICS:
================================================================
Average Resolution Time: ${stats.avgTime} days
Overall Completion Rate: ${stats.snags ? Math.round((stats.snagStatus.completed / stats.snags) * 100) : 0}%

RECOMMENDATIONS:
================================================================
1. Prioritize delayed snags for immediate attention
2. Schedule follow-up inspections for pending items
3. Update CRM system with current status
4. Communicate delays to project team
5. Monitor progress daily

NEXT ACTIONS:
================================================================
- Follow up with project team on critical items
- Schedule reinspection for completed snags
- Update dashboard with latest status
- Generate weekly status report`;
        }
        
        // Generate productivity report
        function generateProductivityReport() {
            const stats = currentStats;
            const dateRange = `${document.getElementById('startDate').value} to ${document.getElementById('endDate').value}`;
            
            return `PRODUCTIVITY REPORT
================================================================
Generated: ${new Date().toLocaleString()}
Date Range: ${dateRange}
Report Type: Team Performance Analysis

PERFORMANCE SUMMARY:
================================================================
Total Activities: ${stats.keys + stats.snags + stats.visits + stats.handovers + stats.moveins}
- Key Handovers: ${stats.keys}
- Snagging Completed: ${stats.snags}
- First Visits: ${stats.visits}
- Handovers: ${stats.handovers}
- Move-ins: ${stats.moveins}

EFFICIENCY METRICS:
================================================================
Average Snag-to-Handover Time: ${stats.avgTime} days
Weekly Average Activities: ${stats.weeklyData.length > 0 ? 
    Math.round((stats.keys + stats.snags + stats.visits + stats.handovers + stats.moveins) / stats.weeklyData.length) : 0}

TOWER PERFORMANCE:
================================================================
Tower A: ${stats.byTower.A.keys + stats.byTower.A.snags + stats.byTower.A.visits + stats.byTower.A.handovers} activities
Tower B: ${stats.byTower.B.keys + stats.byTower.B.snags + stats.byTower.B.visits + stats.byTower.B.handovers} activities
Tower C: ${stats.byTower.C.keys + stats.byTower.C.snags + stats.byTower.C.visits + stats.byTower.C.handovers} activities

RECOMMENDATIONS:
================================================================
1. Focus on improving snag resolution time
2. Balance workload across towers
3. Streamline handover process
4. Monitor weekly productivity trends
5. Set performance targets for next period`;
        }
        
        // Generate trends report
        function generateTrendsReport() {
            const stats = currentStats;
            const dateRange = `${document.getElementById('startDate').value} to ${document.getElementById('endDate').value}`;
            
            // Calculate trends
            const keyTrend = previousPeriodStats.keys > 0 ? 
                ((stats.keys - previousPeriodStats.keys) / previousPeriodStats.keys * 100).toFixed(1) : 'N/A';
            const handoverTrend = previousPeriodStats.handovers > 0 ? 
                ((stats.handovers - previousPeriodStats.handovers) / previousPeriodStats.handovers * 100).toFixed(1) : 'N/A';
            
            return `TREND ANALYSIS REPORT
================================================================
Generated: ${new Date().toLocaleString()}
Date Range: ${dateRange}
Report Type: Performance Trend Analysis

PERIOD COMPARISON:
================================================================
Current Period vs Previous Period:
- Key Handovers: ${stats.keys} (${keyTrend}%)
- Handovers: ${stats.handovers} (${handoverTrend}%)

MONTHLY TRENDS:
================================================================
${stats.monthlyData.labels.map((month, i) => 
    `${month}: ${stats.monthlyData.keys[i]} keys, ${stats.monthlyData.handovers[i]} handovers`
).join('\n')}

WEEKLY PERFORMANCE:
================================================================
${stats.weeklyData.map(week => 
    `${week.week}: ${week.keys} keys, ${week.snags} snags, ${week.visits} visits, ${week.handovers} handovers`
).join('\n')}

KEY INSIGHTS:
================================================================
1. Peak performance periods identified
2. Bottlenecks in the process flow
3. Seasonal variations in activity
4. Team capacity utilization
5. Process improvement opportunities

RECOMMENDATIONS:
================================================================
1. Allocate resources based on peak periods
2. Address identified bottlenecks
3. Implement process improvements
4. Monitor trend changes monthly
5. Set realistic growth targets`;
        }
        
        // Generate alerts report
        function generateAlertsReport() {
            const stats = currentStats;
            const dateRange = `${document.getElementById('startDate').value} to ${document.getElementById('endDate').value}`;
            const hotData = getHOTData();
            
            // Find critical alerts
            const criticalAlerts = [];
            
            ['A', 'B', 'C'].forEach(tower => {
                const towerData = hotData.towers[tower];
                if (towerData && towerData.flats) {
                    Object.entries(towerData.flats).forEach(([flatId, flatData]) => {
                        // Check for snagging delays
                        if (flatData.snagging && flatData.snagging.status !== 'completed') {
                            const startDate = flatData.snagging.startDate ? new Date(flatData.snagging.startDate) : null;
                            if (startDate) {
                                const today = new Date();
                                const daysSinceStart = Math.floor((today - startDate) / (1000 * 60 * 60 * 24));
                                if (daysSinceStart > 7) {
                                    criticalAlerts.push({
                                        tower: tower,
                                        flat: flatId,
                                        issue: 'Snagging delayed',
                                        days: daysSinceStart,
                                        status: flatData.snagging.status
                                    });
                                }
                            }
                        }
                        
                        // Check for incomplete handovers
                        if (flatData.handover && flatData.handover.status !== 'completed') {
                            criticalAlerts.push({
                                tower: tower,
                                flat: flatId,
                                issue: 'Incomplete handover',
                                days: 'N/A',
                                status: 'pending'
                            });
                        }
                    });
                }
            });
            
            return `ALERTS SUMMARY REPORT
================================================================
Generated: ${new Date().toLocaleString()}
Date Range: ${dateRange}
Report Type: Critical Issues and Delays Summary

CRITICAL ALERTS: ${criticalAlerts.length}
================================================================
${criticalAlerts.length > 0 ? criticalAlerts.map(alert => 
    `- Tower ${alert.tower} - Flat ${alert.flat}: ${alert.issue} (${alert.days} days, Status: ${alert.status})`
).join('\n') : 'No critical alerts found'}

PERFORMANCE ALERTS:
================================================================
- Snagging Completion Rate: ${stats.snags > 0 ? Math.round((stats.snagStatus.completed / stats.snags) * 100) : 0}%
- Average Resolution Time: ${stats.avgTime} days (Target: < 7 days)
- Pending Activities: ${stats.snagStatus.pending + stats.snagStatus.delayed}

URGENT ACTIONS REQUIRED:
================================================================
1. Address critical snagging delays immediately
2. Follow up on incomplete handovers
3. Review process bottlenecks
4. Communicate with project team
5. Update stakeholders on resolution timeline

RESOLUTION PLAN:
================================================================
- Assign team members to critical issues
- Set resolution deadlines
- Monitor progress daily
- Escalate unresolved issues after 48 hours
- Document all actions and communications`;
        }
        
        // Download report
        function downloadReport(content, filename) {
            const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            
            const link = document.createElement('a');
            link.href = url;
            link.download = `${filename}_${new Date().toISOString().split('T')[0]}.txt`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            showNotification(`Report "${filename}" downloaded!`, 'success');
        }
        
        // Export as PDF
        function exportAsPDF() {
            if (!hasRealData) {
                alert('No data available to export');
                return;
            }
            
            // Create HTML content for PDF
            const content = document.createElement('div');
            content.innerHTML = `
                <h1>HOTO Process Analytics Report</h1>
                <p>Generated: ${new Date().toLocaleString()}</p>
                <p>Date Range: ${document.getElementById('startDate').value} to ${document.getElementById('endDate').value}</p>
                <h3>Summary Statistics</h3>
                <p>Key Handovers: ${currentStats.keys}</p>
                <p>Snagging Completed: ${currentStats.snags}</p>
                <p>First Visits: ${currentStats.visits}</p>
                <p>Handovers: ${currentStats.handovers}</p>
                <p>Move-ins: ${currentStats.moveins}</p>
            `;
            
            // Use browser's print functionality for PDF
            const printWindow = window.open('', '_blank');
            printWindow.document.write('<html><head><title>HOTO Analytics Report</title></head><body>');
            printWindow.document.write(content.innerHTML);
            printWindow.document.write('</body></html>');
            printWindow.document.close();
            printWindow.print();
            
            showNotification('PDF export initiated', 'success');
        }
        
        // Export as Excel
        function exportAsExcel() {
            if (!hasRealData) {
                alert('No data available to export');
                return;
            }
            
            // Get data from localStorage
            const data = getHOTData();
            
            // Create Excel data
            const wsData = [
                ['Tower', 'Flat', 'Key Handover Date', 'Snagging Start', 'Snagging End', 'First Visit Date', 'Handover Date', 'Move-in Date', 'Status']
            ];
            
            ['A', 'B', 'C'].forEach(tower => {
                const towerData = data.towers[tower];
                if (towerData && towerData.flats) {
                    Object.entries(towerData.flats).forEach(([flatId, flatData]) => {
                        const flatNumber = flatId.split('-')[1];
                        wsData.push([
                            tower,
                            flatNumber,
                            flatData.keyHandover?.date || '',
                            flatData.snagging?.startDate || '',
                            flatData.snagging?.endDate || '',
                            flatData.firstVisit?.visitDate || '',
                            flatData.handover?.date || '',
                            flatData.interiors?.moveInDate || '',
                            getOverallStatus(flatData)
                        ]);
                    });
                }
            });
            
            // Check if SheetJS is available
            if (typeof XLSX === 'undefined') {
                alert('SheetJS library not loaded. Cannot export Excel.');
                return;
            }
            
            // Create worksheet and workbook
            const ws = XLSX.utils.aoa_to_sheet(wsData);
            const wb = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(wb, ws, 'HOT Process Data');
            
            // Export file
            XLSX.writeFile(wb, `HOT_Analytics_${new Date().toISOString().split('T')[0]}.xlsx`);
            
            showNotification('Excel exported successfully!', 'success');
        }
        
        // Helper function to get overall status
        function getOverallStatus(flatData) {
            if (flatData.movein) return 'Completed';
            if (flatData.handover) return 'Handover Done';
            if (flatData.firstVisit) return 'First Visit Done';
            if (flatData.snagging) return 'Snagging in Progress';
            if (flatData.keyHandover) return 'Key Received';
            return 'Not Started';
        }
        
        // Export as CSV
        function exportAsCSV() {
            if (!hasRealData) {
                alert('No data available to export');
                return;
            }
            
            let csvContent = "Tower,Flat,Key Handover,Snagging,First Visit,Handover,Move-in,Status,Last Updated\n";
            
            const data = getHOTData();
            ['A', 'B', 'C'].forEach(tower => {
                const towerData = data.towers[tower];
                if (towerData && towerData.flats) {
                    Object.entries(towerData.flats).forEach(([flatId, flatData]) => {
                        const flatNumber = flatId.split('-')[1];
                        const keyDate = flatData.keyHandover?.date || 'N/A';
                        const snagStatus = flatData.snagging?.status || 'N/A';
                        const visitDate = flatData.firstVisit?.visitDate || 'N/A';
                        const handoverDate = flatData.handover?.date || 'N/A';
                        const moveinDate = flatData.interiors?.moveInDate || 'N/A';
                        const status = getOverallStatus(flatData);
                        const lastUpdated = flatData.keyHandover?.timestamp || 
                                          flatData.snagging?.timestamp || 
                                          flatData.firstVisit?.timestamp || 
                                          flatData.handover?.timestamp || 
                                          'N/A';
                        
                        csvContent += `${tower},${flatNumber},${keyDate},${snagStatus},${visitDate},${handoverDate},${moveinDate},${status},${lastUpdated}\n`;
                    });
                }
            });
            
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            
            const link = document.createElement('a');
            link.href = url;
            link.download = `HOT_Analytics_${new Date().toISOString().split('T')[0]}.csv`;
            link.click();
            
            showNotification('CSV exported successfully!', 'success');
        }
        
        // Print dashboard
        function printDashboard() {
            window.print();
        }
        
        // Show notification
        function showNotification(message, type) {
            // Create notification element
            const notification = document.createElement('div');
            notification.className = `alert alert-${type} alert-dismissible fade show`;
            notification.style.position = 'fixed';
            notification.style.top = '20px';
            notification.style.right = '20px';
            notification.style.zIndex = '9999';
            notification.style.minWidth = '300px';
            notification.innerHTML = `
                ${message}
                <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
            `;
            
            document.body.appendChild(notification);
            
            // Auto remove after 3 seconds
            setTimeout(() => {
                notification.remove();
            }, 3000);
        }
    </script>
</body>
</html>
